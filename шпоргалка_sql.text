"""
...
cur.executescript('''
CREATE TABLE IF NOT EXISTS directors(
    id INTEGER PRIMARY KEY,
    name TEXT,
    birthday_year INTEGER
);

CREATE TABLE IF NOT EXISTS movies(
    id INTEGER PRIMARY KEY,
    name TEXT,
    type TEXT,
    release_year INTEGER
);
''')
... 
"""



"""
...
directors = [
    (1, 'Текс Эйвери', 1908),
    (2, 'Роберт Земекис', 1952),
    (3, 'Джерри Чиникей', 1912),
]
movies = [
    (1, 'Весёлые мелодии', 'Мультсериал', 1930),
    (2, 'Кто подставил кролика Роджера', 'Фильм', 1988),
    (3, 'Безумные Мелодии Луни Тюнз', 'Мультсериал', 1931),
    (4, 'Розовая пантера: Контроль за вредителями', 'Мультфильм', 1969),
]

cur.executemany('INSERT INTO directors VALUES(?, ?, ?);', directors)
cur.executemany('INSERT INTO movies VALUES(?, ?, ?, ?);', movies)


------------------
  SELECT name       
  FROM movies
  -- Найдём фильмы, выпущенные позже 1988:
  WHERE release_year > 1988;
  
  
  SELECT name       
  FROM movies
  -- Найдём фильмы, выпущенные с 1980 по 1990 год включительно:
  WHERE release_year BETWEEN 1980 AND 1990;
  
  SELECT name       
  FROM movies
  -- Найдём в базе все фильмы, 
  -- у которых значение поля type - 'Сериал' или 'Фильм':
  WHERE type IN ('Сериал', 'Фильм');
  
  LIKE — поиск строки по шаблону; в шаблонах можно применять символы-«маски»: 
  знак процента (%) заменяет любой набор символов; 
  символ подчёркивания _ заменяет один любой символ 
  (цифру, букву, пробел, пунктуационный или любой другой символ).
  
  SELECT name       
  FROM movies
  WHERE type LIKE 'Мульт%';
   
 ...
cur.execute('''
SELECT name,
       release_year
FROM movies
WHERE (release_year BETWEEN 1965 AND 1990) AND type LIKE '%ильм';
''')

for result in cur:
    print(result)
...  


Направление сортировки
По умолчанию, команда ORDER BY выполняет сортировку по возрастанию. Чтобы управлять направлением сортировки вручную, после имени столбца указывается ключевое слово ASC (по возрастанию) или DESC (по убыванию). 
Вывести фильмы в порядке «от новых к старым» можно так:
...
ORDER BY release_year DESC; 


При постраничном размещении информации эти две записи можно выкладывать на первую страницу. На вторую страницу нужно вывести третью и четвёртую записи.
Если нужно вернуть определённое число записей, но начинать нужно не с первой записи в выборке — после LIMIT ставят оператор OFFSET и в нём указывают, сколько записей нужно пропустить.
Вернём две записи из нашей выборки, но две первые пропустим:
SELECT type,
       name       
FROM movies
ORDER BY name
LIMIT 2 OFFSET 2; 



SELECT MIN(gross)
FROM movies;
-- Вернёт: 25118063
 
SELECT MAX(gross)
FROM movies;
-- Вернёт: 156452370  
Функции MIN и MAX игнорируют значения NULL. Чего нет — то не может быть подсчитано.
Найти минимальное или максимальное значение можно и без агрегирующих функций — для этого сортируем таблицу по заданному полю и берём первое значение. Но такой запрос будет работать намного дольше, чем агрегатные функции.
AVG и SUM
Часто требуется получить средние значения и итоговую сумму по какому то столбцу. SQL может вернуть и такие данные: для этого есть агрегирующие функции AVG (от англ. average «среднее») и SUM (от англ. «сумма»). Эти функции тоже игнорируют значения NULL. Подсчитываемая выборка может быть ограничена с помощью WHERE. 
Примеры использования: 
SELECT AVG(gross)
FROM movies
WHERE release_year > 1980;
-- Вернёт: 146875429.5

SELECT SUM(gross)
FROM movies
WHERE release_year > 1980;
-- Вернёт: 293750859 
В веб-разработке SUM часто используется для подсчёта итоговой суммы в заказе, а AVG — для работы со всевозможными рейтингами.


COUNT
Агрегирующая функция COUNT() (англ. «подсчёт») возвращает количество строк в результирующей выборке.
Этот запрос переводится с SQL на русский как «СОСЧИТАЙ все строки в таблице movies»:
SELECT COUNT(*)
FROM movies; 


Самый простой вариант использования GROUP BY — найти «группы», объединённые одинаковым значением в заданной колонке:
SELECT type
FROM movies
GROUP BY type; 
Все записи с одинаковыми значениями в поле type были объединены в группы, и в ответ на запрос вернулось по одной записи из каждой «группы»:
('Мультсериал',)
('Мультфильм',)
('Сериал',)
('Фильм',) 


Аналогично ключевому слову DISTINCT, этот оператор может вернуть уникальные значения поля:
SELECT type
FROM movies
GROUP BY type;

-- Тот же результат вернётся и при таком запросе:
SELECT DISTINCT type
FROM movies; 


Посчитаем (COUNT), сколько в таблице фильмов каждого типа — сколько фильмов, сколько сериалов, сколько мультфильмов и мультсериалов:
SELECT type,
       COUNT(*)
FROM movies
GROUP BY type; 
Получилось!
('Мультсериал', 2)
('Мультфильм', 1)
('Сериал', 3)    
('Фильм', 4) 


Найдём самый старый фильм (MIN) в каждой группе: 
SELECT type,
       MIN(release_year)
FROM movies
GROUP BY type; 


Просуммируем кассовые сборы (SUM) для фильмов разного типа: 
SELECT type,
       SUM(gross)
FROM movies
GROUP BY type; 
Вернётся такой ответ:
('Мультсериал', None)
('Мультфильм', None)
('Сериал', None)
('Фильм', 318868922) 
------------------
