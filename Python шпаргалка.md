# Python

- Команды
    
    print() - выводит информацию в консоль. 
    
    - Необязательные аргументы команды print()
        1. **sep** - разделитель (separator), служит для установки определенного знака между выводимыми значениями. Например: **print('a', 'b', 'c', sep='*')** выведет в консоль **a*b*c ; print('d', 'e', 'f', sep='**')** выведет в консоль **d**e**f**
        2. **end** - окончание. Если перевод строки делать не нужно или требуется указать специальное окончание, то следует явно указать значение для параметра `end`. Например:
        
        print('a', 'b', 'c', end='@')
        print('d', 'e', 'f', end='@@')
        
        Результатом будет 
        
        ```
        a b c@d e f@@
        ```
        
        ```python
        end='\n' переводит на новую строку,
        end='\n\n\n' в данном случае на 3 строки
        ```
        
    
    print(’…’) - выводит в консоль строковые значения. Могут использоваться как ‘ ‘ одинарный так и “ “ двойные кавычки.
    
    input() — используется для считывания данных, то есть для ввода данных пользователем. Cчитывает введенные с клавиатуры данные. `input()`по умолчанию считывает именно **текст.**
    
    int() — **Преобразование строки к целому числу.**
     Для того, чтобы преобразовать строку к целому числу, мы используем команду `int()` **num = int(input()) преобразует данные в целое число и присвоит переменной num.** Сокращение `int` происходит от английского **integer**  – целый.
    
    str() — **Преобразование целого числа к строке.**
     Для того, чтобы преобразовать целое число в строку, мы используем команду `str()`
    
    float() — число с плавающей запятой `float()`
    
    **a,b = map(int,input().split()) —** если необходимо ввести два целых числа в одну строку через пробел
    
    **a,b,c = map(float,input().split()) —** если необходимо ввести три вещественных числа в одну строку через пробел
    
    **math.trunc(32.2)** → 32 — функция отсекает дробную часть числа.
    **math.floor(32.1)** → 32 — округление вниз.
    
    **math.ceil(32.1**) → 33 — округление вверх.
    
- Условные операторы
    - If — else
        
        В Python существует несколько способов проверки, и в каждом случае возможны два исхода: истина (True) или ложь (False).
        
        Двоеточие (:) в конце строки с инструкцией `if`
         сообщает интерпретатору Python, что дальше находится **блок команд**. В блок команд входят все строки с отступом под строкой с инструкцией `if`
        , вплоть до следующей строки без отступа.
        
        ![Untitled](Python%20af5b9e26b49344a48e40a66cfe665eac/Untitled.png)
        
        ![Untitled](Python%20af5b9e26b49344a48e40a66cfe665eac/Untitled%201.png)
        
        По соглашению PEP 8, для отступа блоков кода используются **4 пробела**. Если в среде Wing IDE нажать на клавишу Enter после `if`, она автоматически выставит **4 пробела**.
        
        **elif** - это аналог if else в С#
        
    - Операторы сравнения
        
        == — проверка двух элементов на равенство.
        
        if x > 7 — если х больше 7;
        
        if x < 7 — если х меньше 7;
        
        if x >= 7 — если х больше либо равен 7;
        
        if x <= 7 — если х меньше либо равен 7;
        
        if x == 7 — если х равен 7;
        
        if x != 7 — если х не равен 7.
        
    - Цепочки сравнения
        
        Операторы сравнения в Python можно объединять в цепочки (в отличии от большинства других языков программирования, где для этого нужно использовать логические связки), например, `a == b == c` или `1 <= x <= 10`. Следующий код проверяет, находится ли значение переменной `age` в диапазоне от 3 до 6:
        
        ```python
        age = int(input())
        if 3 <= age <= 6:
        		print('Вы ребёнок')  
        ```
        
        Код, проверяющий равенство трех переменных, может выглядеть так:
        
        ```python
        if a == b == c:
            print('числа равны')
        else:
            print('числа не равны')
        ```
        
    - Транзитивность
        
        Из курса математики вам могут быть знакомы другие примеры транзитивных операций:
        
        - **Отношение порядка:** если a > b и b > c, то a > c;
        - **Параллельность прямых:** если a ∥ *b* и b ∥ *c*, то a ∥ *c*;
        - **Делимость:** если a делится на b и b делится на c, то a делится на c
        
        Операция неравенства (!=), в отличие от операции равенства (==), является [нетранзитивной](https://ru.wikipedia.org/wiki/%D0%9D%D0%B5%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B8%D1%82%D0%B8%D0%B2%D0%BD%D0%BE%D1%81%D1%82%D1%8C). То есть из того, что `a != b` и `b != c`, вовсе не следует, что `a != c`.
        
- Логические операторы
    
    **and** - логическое умножение И. Выполняется только при выполнении **обоих условий**
     **одновременно**!;
    
    **or** - логическое сложение ИЛИ. Выполнения блока кода достаточно выполнения **хотя бы одного из условий**.;
    
    **not** - логическое отрицание НЕ. Позволяет инвертировать (т.е. заменить на противоположный) результат логического выражения.
    
    • в первую очередь выполняется логическое отрицание `not`; • далее выполняется логическое умножение `and`; алее выполняется логическое сложение `or`.
    
- Циклы
    
    [Шпаргалка_по_циклам.pdf](Python%20af5b9e26b49344a48e40a66cfe665eac/py02.pdf)
    
    - **for переменная in список_элементов** — *Объявление цикла for.*
        
        ![Untitled](Python%20af5b9e26b49344a48e40a66cfe665eac/Untitled%202.png)
        
        ```python
        bremen_musicians = ['Кот', 'Пёс', 'Трубадур', 'Осёл', 'Петух']
        # Код цикла
        for musician in bremen_musicians:
            # Каждый элемент списка bremen_musicians 
            # по очереди будет передан в переменную musician
            # и напечатан
            print(musician)
        
        # Код, который выполняется после цикла
        print('Нам дворцов заманчивые своды не заменят никогда свободы!')
        ```
        
    - **Диапазоны от и до**
        
        ```python
        three = range(0, 3)
        # Последовательность three будет включать в себя числа 0, 1 и 2.
        # Тройка в эту последовательность не войдёт: 
        # последнее число в последовательность не включается.
        ```
        
        ```python
        # Приятная особенность последовательности range() состоит в том, 
        # что её можно обрабатывать в цикле, как обычный список.
        
        around_zero = range(-3, 3)
        
        # Вместо списка в цикл передаётся переменная around_zero, 
        # в ней хранится range() от -3 до 3
        for i in around_zero:
            # Перебрать все числа в диапазоне от -3 до 3 и напечатать их:
            print(i)
        # Будет напечатано
        # -3
        # -2
        # -1
        # 0
        # 1
        # 2
        ```
        
        ```python
        # Цикл переберёт все числа в диапазоне от -3 до 3 и напечатает их:
        for i in range(-3, 3):
            print(i)
        
        # Результат будет тот же
        ```
        
        Если нужно пройтись по списку или по диапазону чисел в обратном порядке — вызывайте функцию **reversed()**: она переворачивает и список, и диапазон; чтение любой последовательности начнётся с конца.
        
        ```python
        for i in reversed(range(1, 13)):
            print(i, 'бомм!')
        
        print('C новым годом!')
        ```
        
        ```python
        # Можно обратить вспять обычный список: 
        seasons = ['зима', 'весна', 'лето', 'осень']
        
        for season in reversed(seasons):  
            # Переменную цикла, в которую 
            # будут передаваться элементы "перевёрнутого" списка seasons,
            # назовём season
            print(season)
        ```
        
- **Функции**
    
    Функция это фрагмент программы, используемый многократно.
    
    [Шпаргалка по функциям.pdf](Python%20af5b9e26b49344a48e40a66cfe665eac/%25D0%25A8%25D0%25BF%25D0%25B0%25D1%2580%25D0%25B3%25D0%25B0%25D0%25BB%25D0%25BA%25D0%25B0_%25D0%25BF%25D0%25BE_%25D1%2584%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D1%258F%25D0%25BC.pdf)
    
    **def** — объявляет (создает) функцию.
    
    Функции можно создавать в отдельном файле и через **import** импортировать в нужный файл. **import function_name as h** — в данном случае происходит импортировании функции **function_name** и переименовании ее в **h**
    
    ```python
    def new_string(symbol, count = 3): # функция которая принимает два аргумента, но если второй не бедет передан, будет заменен на 3. 
    		return symbol * count          # функция возвращает произведение двух аргументов.
     
    print(new_string('!', 5)) # !!!!!
    print(new_string('!'))    # !!!
    print(new_string(4))      # 12, т.к. 4*3=12 
    ```
    
    ```python
    def concatenatio(*params): # функция с неограниченным числом аргументов;
    		res: str = ''
    		for item in params:
    				res += item
    		return res
    
    print(concatenatio('a', 's', 'd', 'w')) # asdw
    print(concatenatio('a', '1'))           # a1
    ```
    
    - Рекурсия — это функция которая вызывает сама себя.
        
        ```python
        def fib(n):
        		if n in [1, 2]:
        				return 1
        		else:
        				return fib(n-1) + fib(n-2)
        
        list = []
        for e in range(1, 10):
        		list.append(fib(e))
        print(list)             # 1 1 2 3 5 8 13 21 34 
        ```
        
- **Коллекции:** Словари, Множества, Кортеж и Списки
    - Коллекция: Проверить, есть ли в коллекции определённый элемент, можно условной конструкцией `if` с оператором `in`.
        
        ```python
        # Список (list): в квадратных скобках:
        sleep_list = [
            'спать', 
            'дрыхнуть', 
            'кемарить',
            'спать'
        ] 
        
        # Множество (set): в фигурных скобках, элементы выглядят как в списке,
        # но не могут повторяться:
        sleep_set = {
            'дрыхнуть', 
            'спать', 
            'кемарить'
        } 
        # Словарь (dict): в фигурных скобках, элементы выглядят как ключ:значение;
        # ключи не могут повторяться:
        sleep_dict = {
            'спать': 'дрыхнуть', 
            'почивать': 'кемарить'
        }
        
        # Есть ли элемент 'дрыхнуть' в списке sleep_list?
        if 'дрыхнуть' in sleep_list:
            print('В списке: нашлось!') 
        else:
            print('В списке: не нашлось :(')
        
        # Есть ли элемент 'дрыхнуть' в сете sleep_set?
        if 'дрыхнуть' in sleep_set:
            print('В сете: нашлось!') 
        else:
            print('В сете: не нашлось :(')
        
        # Есть ли элемент 'дрыхнуть' в словаре sleep_dict?
        if 'дрыхнуть' in sleep_dict:
            print('В словаре: нашлось!') 
        else:
            print('В словаре: не нашлось :(')
        ```
        
        Оператором `in` у словарей есть особенность: этот оператор проводит поиск только по **ключам.**
        
        **Добавление элементов в коллекции: В список** можно добавить новый элемент методом **append()**. Новый элемент будет добавлен в конец списка.
        
        Добавить новый элемент **в множество** можно методом `add()`.
        
    - Списки
        
        ```python
        list1 = [1, 2, 3, 4, 5] 
        УДАЛЕНИЕ ЭЛЕМЕНТА СПИСКА
        list1.pop(2)          # удалит элемент с индексом 2
        print(list1)          # [1, 2, 4, 5]
        ДОБАВЛЕНИЕ ЭЛЕМЕНТА В СПИСОК, на любой место в списке
        list1.insert(2, 11)   # добавит 11 на 2 индекс 
        print(list1)          # [1, 2, 11, 3, 4, 5] 
        ДОБАВЛЕНИЕ, к конец списка
        list1.append(11)      # добавит 11 в конец списка
        print(list1)          # [1, 2, 3, 4, 5, 11]
        ```
        
    - Кортеж — это неизменяемый “список”.
        
        ```python
        a = (3, 1, 5, 4)
        print(a)     # (3, 1, 5, 4)
        print(a[0])  # 3
        print(a[-1]) # 4
        a[] = 12     # будет ошибка, т.к. кортеж не изменяемый список и допалнять его нельзя
        ```
        
        ```python
        Перебирание кортежа циклом for
        a = (3, 4, 5)
        for item in a:
        		print(item)  # 3
        								 # 4
        								 # 5	
        ```
        
        ```python
        Конвертирование списка в кортеж
        t = tuple(['red', 'green', 'blue'])
        red, green, blue = t
        print('r:{} g:{} b:{}'.format(red, green, blue))
        # r:red g:green b:blue 
        ```
        
    - Словари — неупорядоченные коллекции произвольных объектов с доступом по ключу. Тип данных **dict**.
        
        [Словари и множества.pdf](Python%20af5b9e26b49344a48e40a66cfe665eac/%25D0%25A1%25D0%25BB%25D0%25BE%25D0%25B2%25D0%25B0%25D1%2580%25D0%25B8_%25D0%25B8_%25D0%25BC%25D0%25BD%25D0%25BE%25D0%25B6%25D0%25B5%25D1%2581%25D1%2582%25D0%25B2%25D0%25B0.pdf)
        
        Словарь (dict) оформляется фигурными скобками. Его заполняют пары, записанные через запятую. Первый элемент в паре называется ключ, а второй — значение, они разделяются между собой двоеточием.
        
        ```python
        dictionary = {}  # называться может как угодно, главное код внутки {}
        dictionary = \
        		{
        				'up': '↑',        # слева ключ, справа значение
        				'left': '←',
        				'down': '↓',
        				'right': '→'
        		}
        print(dictionary)         # {'up': '↑', 'left': '←', 'down': '↓', 'right': '→'}
        print(dictionary['left']) # '←'
        ```
        
        - **Доступ к значению словаря по ключу:** Чтобы получить из словаря определённое **значение** — в коде указывают **ключ**, значение которого нужно получить; это называется «доступ по ключу».
            
            ```python
            english = {
                'рука': 'hand',
                'нога': 'leg',
                'хвост': 'tail',
                'питон': 'python',
                'бэкенд-разработчик': 'back-end developer'
            }
            
            # Доступ по ключу: как по-английски рука?
            print(english['рука'])
            # Вывод будет: hand
            ```
            
        - **Уникальность ключей в словаре: Значением** в словаре может быть вообще что угодно: числа, строки, списки и даже другие словари. Значения словаря не обязаны быть уникальными и могут повторяться.
            
            ```python
            dump = {
                1: 'единица',               # Ключ - число, значение - строка.
                'земляника': 'ягода',       # И ключ, и значение - строки.
                'помидор': 'ягода',         # Значение 'ягода' - не уникально. Так можно.
                False: 0,                   # Ключ - булево значение, значение - число.
                'лук': ['овощ', 'оружие'],  # Ключ - строка, значение - список.
                                            # Ключ - строка, а значение - словарь. Так тоже можно!
                'англо-русский словарь': {'рука': 'hand', 
                                          'нога': 'leg', 
                                          'бэкенд-разработчик': 'back-end developer'
                                           },    
            }
            
            print(dump['лук'])
            # Будет напечатано ['овощ', 'оружие']
            ```
            
        - **Добавление одного элемента в словарь:** Для добавления нового элемента можно применить доступ по ключу: объявить новый ключ словаря и присвоить ему значение.
            
            ```python
            english = {
                'рука': 'arm',
                'нога': 'leg',
                'хвост': 'tail',
                'питон': 'python',
                'бэкенд-разработчик': 'back-end developer'
            }
            
            # Создаём новый элемент словаря через доступ по ключу
            english['голова'] = 'head'
            ```
            
        - **Одновременное добавление нескольких элементов:** У словарей есть метод  `update()`, он позволяет объединить два словаря, то есть добавить в один словарь элементы другого.
            
            ```python
            english = {
                'рука': 'arm',
                'нога': 'leg',
                'хвост': 'tail',
                'питон': 'python',
                'бэкенд-разработчик': 'back-end developer',
                'голова': 'head'
            }
            
            # Объявим новый словарь
            new_words = {'мозг': 'brain', 'логика': 'logic'}
            
            # Добавим в словарь english элементы словаря new_words
            english.update(new_words)
            
            # Посмотрим, что теперь хранится в словаре english
            print(english)
            # Выдаст: {'рука': 'arm', 'нога': 'leg', 'хвост': 'tail', 'питон': 'python', 'бэкенд-разработчик': 'back-end developer', 'голова': 'head', 'мозг': 'brain', 'логика': 'logic'}
            
            # Заодно выясним, что произошло со словарём new_words
            print(new_words)
            # Выдаст: {'мозг': 'brain', 'логика': 'logic'} 
            ```
            
        - В любом элементе словаря можно заменить существующее значение на новое.
            
            ```python
            english = {
                'рука': 'hand',
            	'нога': 'leg',
                'хвост': 'tail',
                'питон': 'python',
            	'бэкенд-разработчик': 'back-end developer'
            }
            
            # Элементу с ключом 'рука' присвоим новое значение
            english['рука'] = 'arm'
            
            print(english['рука'])
            # Вывод будет: arm
            ```
            
        - Значения всех ключей можно извлечь из словаря и собрать в одну коллекцию. Для этого у словаря есть метод `values()`
            
            ```python
            # Словарь, в котором хранятся начертания букв и их названия
            old_letters = {
                'ять': 'Ѣ',
                'юс малый': 'Ѧ',
                'юс большой': 'Ѫ'}
            
            print(old_letters.values())
            # Будет напечатан список значений словаря
            # dict_values(['Ѣ', 'Ѧ', 'Ѫ'])
            ```
            
        - Можно получить и коллекцию ключей словаря, для этого есть метод `keys()`:
            
            ```python
            favorite_songs = {
                'Тополиный пух': 'Иванушки international',
                'Город золотой': 'Аквариум',
                'Звезда по имени Солнце': 'Кино'
            }
            
            print(favorite_songs.keys()) 
            # Будет напечатан список ключей словаря
            # dict_keys(['Тополиный пух', 'Город золотой', 'Звезда по имени Солнце'])
            ```
            
        
        ```python
        Получение всех ключей или значений "словаря"
        for k in dictionary.keys()    # запрос всех ключей;
        for k in dictionary.values()  # запрос всех значений;
        ```
        
        - **Перебор элементов словаря:** перебрать весь словарь можно циклом **for** используя метод `items()`. ****
            
            Этот метод извлекает из каждого элемента словаря ключ и значение и передаёт их в переменные `song` и `performer`. Имена для этих переменных разработчик может выбирать на свой вкус, они могут быть любыми; для читаемости кода их часто именуют `key` (англ. «ключ») и `value` (англ. «значение»)
            
            ```python
            favorite_songs = {
                'Тополиный пух': 'Иванушки international',
                'Город золотой': 'Аквариум',
                'Звезда по имени Солнце': 'Кино',
                'Space Oddity': 'David Bowie',
                'Рыба': 'Аквариум',
                'Серенада Трубадура': 'Муслим Магомаев',
            }
            
            for song, performer in favorite_songs.items():
            	print('Песню ' + song + ' исполняет ' + performer)
            # Выведет: 
            # Песню Тополиный пух исполняет Иванушки international
            # Песню Город золотой исполняет Аквариум
            # Песню Звезда по имени Солнце исполняет Кино
            # Песню Space Oddity исполняет David Bowie
            # Песню Рыба исполняет Аквариум
            # Песню Серенада Трубадура исполняет Муслим Магомаев
            ```
            
            ![Untitled](Python%20af5b9e26b49344a48e40a66cfe665eac/Untitled%203.png)
            
    - Множества — Одна из разновидностей коллекций в Python — это **множества**, тип данных *set*. По структуре множества очень похожи на списки: в коде они записываются как перечень элементов, разделённых запятой. Элементы множества замыкаются в фигурные скобки `{ }`.
        
        Одна из особенностей сетов: в памяти компьютера элементы сета хранятся в неупорядоченном виде и выводятся в случайном порядке. set не поддерживает индексы, а следовательно нельзя по немцу обратиться. 
        
        Можно преобразовать список в множество через **set(имя_списка)**
        
        [Словари и множества.pdf](Python%20af5b9e26b49344a48e40a66cfe665eac/%25D0%25A1%25D0%25BB%25D0%25BE%25D0%25B2%25D0%25B0%25D1%2580%25D0%25B8_%25D0%25B8_%25D0%25BC%25D0%25BD%25D0%25BE%25D0%25B6%25D0%25B5%25D1%2581%25D1%2582%25D0%25B2%25D0%25B0%201.pdf)
        
        ```python
        colors = {'red', 'green', 'blue'}
        print(colors)        # {'red', 'green', 'blue'}
        colors.add('gray')   # добавление в множество;
        print(colors)        # {'red', 'green', 'blue', 'gray'}
        colors.remove('red') # удаление из множества;
        print(colors)        # {'green', 'blue', 'gray'}
        colors.clear()       # очистить множество;
        print(colors)        # { }
        ```
        
        ```python
        a = {1, 2, 3, 5, 8}
        b = {2, 5, 8, 13, 21}
        c = a.copy()           # скопирует множество: c = {1, 2, 3, 5, 8}
        u = a.union(b)         # объединит два множества: u = {1, 2, 3, 5, 8, 13, 21}
        i = a.intersection(b)  # пересечение множеств  i = {8, 2, 5}
        dl = a.difference(b)   #   dl = {1, 3}
        dr = b.aifference(a)   #   dr = {13, 21}
        ```
        
        ```python
        Замороженое множество:
        s = frozenset({1, 2, 3})  # данное множество нельзя будет изменить
        ```
        
        Добавление нового элемента в множество методом **add()**. Метод `add()` в качестве аргумента принимает значение, которое нужно добавить в множество. Этот метод может добавить лишь один элемент; чтобы добавить несколько элементов — нужно вызвать метод `add()` несколько раз с разными аргументами.
        
        ```python
        playlist = {
            'Venus',
            'Yesterday',
            'Fireball',
            'Time',
            'Poison'
        }
        
        playlist.add('Thunderstruck')
        print(playlist)
        # Будет напечатано: 
        # {'Yesterday', 'Fireball', 'Thunderstruck', 'Poison', 'Venus', 'Time'}
        # Элементы множеств никогда не соблюдают порядок!
        ```
        
        - **Объединение двух множеств:** Метод `union()` применяют для объединения двух множеств. Метод применяется к одному множеству, а в аргументе передаётся второе. ****
            
            ```python
            playlist_1 = {'Три белых коня', 'Happy new year', 'Снежинка'}
            playlist_2 = {'Last christmas', 'Снежинка', 'Happy new year'}
            # Метод применяется к одному множеству, а в аргументе передаётся второе.
            playlist_3 = playlist_1.union(playlist_2)
            
            print(playlist_3)
            # Выводом будет: {'Happy new year', 'Last christmas', 'Три белых коня', 'Снежинка'}
            ```
            
        - **Поиск различий в двух множествах:** Если нужно найти песни, которые присутствуют в одном плейлисте, но отсутствуют во втором — поможет метод `difference()`.
            
            ```python
            # Метод set_1.difference(set_2) вернёт новое множество, оно будет содержать
            # только те элементы, которые присутствуют в set_1, но отcутствуют в set_2; 
            # это похоже на «вычитание»: set_1 - set_2.
            playlist_1 = {'Голубой вагон', 'Облака', 'Yesterday', 'Наше лето'}
            playlist_2 = {'Наше лето', 'Голубой вагон', 'Облака'}
            playlist_3 = playlist_1.difference(playlist_2)
            
            print(playlist_3)
            # Выводом будет: {'Yesterday'}
            ```
            
        - **Поиск одинаковых элементов в двух множествах:** Можно найти пересечение двух множеств, то есть элементы, которые есть и в первом, и во втором множестве.
            
            ```python
            films_1 = {'Форсаж', 'Достучаться до небес', 'Мстители: война бесконечности'}
            films_2 = {'Мстители: война бесконечности', 'Форсаж', 'Матрица'}
            films_3 = films_1.intersection(films_2)
            
            print(films_3)
            # Выводом будет: {'Мстители: война бесконечности', 'Форсаж'}
            ```
            
- **Строки** — **упорядоченная коллекция**, иначе каждый раз при печати выводилась бы нечитаемая чепуха, где все буквы перепутаны.
    
    [Строки шпаргалка.pdf](Python%20af5b9e26b49344a48e40a66cfe665eac/%25D0%25A1%25D1%2582%25D1%2580%25D0%25BE%25D0%25BA%25D0%25B8_%25D1%2588%25D0%25BF%25D0%25B0%25D1%2580%25D0%25B3%25D0%25B0%25D0%25BB%25D0%25BA%25D0%25B0.pdf)
    
    - Методы строк:
        1. **метод** `split()` — разделить строку на слова или на другие фрагменты текста — и сохранить получившиеся подстроки в список. Для этого метода можно указать аргумент — разделитель, по которому строка будет разбита на части. Разделителем может быть цифра, буква, пробел или любой набор символов. Чтобы разделить строку на слова — в качестве разделителя нужно указать пробел, это такой же символ, как буква или цифра. Если аргументом метода `split()` будет пробел — то фраза, к которой будет применён этот метод, будет разбита на отдельные слова.
        2. метод `join()` — создает строку из коллекции. У метода `join()` синтаксис отличается от `split()`: метод применяется к строке-разделителю, а список передаётся как **аргумент** метода, пример: `new_string = '-'.join(words_list)`. Разделителем может быть любая строка: какое-нибудь слово, запятая с пробелом `', '`, пробел `' '`, а может быть «пустая строка» `''` — кавычки, между которыми ничего нет, даже пробела.
        3. 
- Lambda
- **Метод** — это разновидность функции, мини-программа. Однако, в отличие от функций, метод применяется к **объекту**, например — к строке, к числу или к множеству. У строк — свои методы, у чисел — свои, у множеств — свои.
    
    Методы применяются к конкретным объектам и выполняют с ними какие-то действия. Чтобы применить метод к какому-то объекту, в коде записывают имя объекта, ставят точку и после неё пишут название метода с круглыми скобками (в скобках могут быть аргументы, как у функции): `объект.метод(аргумент)`.
    
    - Методы списков
        1. list**.extend**((a, b, c)) — добавление переменных в список;
        2. list**.count()** — если необходимо узнать, сколько раз в списке присутствует тот или иной элемент;
        3. list.**sort()** — ****сортировка по возрастанию элементов;
        4. list**.reverse()** — возвращает в обратный порядок отсортированный список;
        5. 
- **Библиотеки**
    
    [Библиотеки шпаргалка.pdf](Python%20af5b9e26b49344a48e40a66cfe665eac/%25D0%2591%25D0%25B8%25D0%25B1%25D0%25BB%25D0%25B8%25D0%25BE%25D1%2582%25D0%25B5%25D0%25BA%25D0%25B8_%25D1%2588%25D0%25BF%25D0%25B0%25D1%2580%25D0%25B3%25D0%25B0%25D0%25BB%25D0%25BA%25D0%25B0.pdf)
    
    Чтобы получить доступ к библиотекам, нужно в начале программы импортировать библиотеку командой `import` — «подключить» её. Тогда в коде можно будет применять все функции, которые есть в библиотеке.
    
    Если все функции библиотеки не нужны, можно импортировать только те, которые требуются: `from random import choice` (из библиотеки `random` подключить функцию `choice`).
    
    Иногда у библиотек очень длинные имена, и, если не хочется при каждом вызове писать её полное имя и загромождать код, при импорте можно дать библиотеке короткий «псевдоним» через ключевое слово `as`
    
    - Список библиотек:
        1. функция `random.randint(min, max)` выберет случайное целое число в диапазоне от числа min до числа max;
        2. функция `random.choice(список)` вернёт случайный элемент из списка;
        3. функция `random.random()` вернёт случайное дробное число от 0.0 до 1.0.
        4. библиотека `urllib.parse` кодировать URL: **urllib.parse.quote(name_строки)** *# зашифрованная строка;* **urllib.parse.unquote(name_строки)** *# расшифрованная обратно строка*
        5. Библиотека `requests` метод `get()` отправляет GET-запросы к веб-сайту и получает ответ от сервера, который можно сохранить в переменной в виде текста. 
    
- Работа с файлами
    
    a — открытие для добавления данных;
    
    r — открытие для чтения данных;
    
    w — открытие для записи данных;
    
    ```python
    # ЗАПИСЬ ДАННЫХ, в файл.
    # Первый способ:
    colors = ['red', 'green', 'blue']
    data = open('file.txt', 'a') # открывает файл fail.txt для внесения данны.
    # если файл отсутсвует создаест его. 
    data.writelines(colors) # разделителей не будет 
    data.close() # закрытие работы с файлом, по окончании работы файл надо обязательно закрыть
    
    # Второй способ:
    with open('file.txt', 'a') as data:
    		data.write('line1 \n')
    		data.rwite('line2 \n') # При такой записи не нужно закрывать файл data.close()
    ```
    
    ```python
    # ЧТЕНИЕ ДАННЫХ, из файл.
    path = 'file.txt' # Путь к файлу который надо прочесть;
    data = open(path, 'r') # Открытие файла для чтения;
    for line in data: # Через цикл идет чтение файла
    		print(line)
    data.close()
    ```
    
- Работа с базами данных БД
    
    Метод **sqlite3** подключатся через import: import sqlite3
    
    ***con = sqlite3.connect('db.sqlite')*** — команда создает файл db.sqlite (при отсутствии в директории файла db.sqlite) и соединяет его с базой, если файл уже есть просто подключает его к базе.
    
    ```sql
    SELECT ('столбцы (* - для выбора всех столбцов); обязательно')
    (могут применяться агрегатные функции COUNT, MIN, MAX, AVG и SUM; необязательно)
    (и ключевое слово DISTINCT; необязательно)
    FROM ('таблица; обязательно')
    WHERE ('условие/фильтрация; необязательно')
    GROUP BY ('столбец, по которому нужно сгруппировать данные; необязательно')
    HAVING ('условие/фильтрация на уровне сгруппированных данных; необязательно')
    ORDER BY ('столбец, по которому нужно ранжировать вывод; необязательно')
    LIMIT ('сколько записей показывать; необязательно')
    OFFSET ('сколько записей в выборке пропустить; необязательно')
    ```
    
- Сетевые запросы, библиотека  `requests`
    
    [Шпаргалка по сетевым запросам.pdf](Python%20af5b9e26b49344a48e40a66cfe665eac/%25D0%25A8%25D0%25BF%25D0%25B0%25D1%2580%25D0%25B3%25D0%25B0%25D0%25BB%25D0%25BA%25D0%25B0_%25D0%25BF%25D0%25BE_%25D1%2581%25D0%25B5%25D1%2582%25D0%25B5%25D0%25B2%25D1%258B%25D0%25BC_%25D0%25B7%25D0%25B0%25D0%25BF%25D1%2580%25D0%25BE%25D1%2581%25D0%25B0%25D0%25BC.pdf)
    
    ```python
    # Пример запросов:
    import requests # Импорт библиотеки requests
    
    url = 'http://wttr.in/Moscow?0T' # адрес веб-сайта откуда берутся данные
    
    response = requests.get(url)  # выполните HTTP-запрос
    
    print(response.text)  # напечатайте текст HTTP-ответа
    ```
    
    Python умеет удобно формировать адреса URL, подставляя в них параметры из словаря. Функция `get()` сама производит нужные преобразования, нужно лишь передать параметры через *именованный аргумент* `params`.
    
- Знания
    1. Переменные водятся без дополнительных команд **name = Maksim**  тут мы назвали переменную name и присвоили ей значение Maksim.
    2. Нельзя использовать в качестве переменных:  False; True; None; and; with; as; assert; break; class; continue; def; del; elif; else; except; finally; try; for; from; global; if; import; in; is; lambda; nonlocal; not; or; pass; raise; return; while; yield.
    3. После запятой нужен пробел. **print('PEP8', 'Rocks!')**
    4. Не отделяйте пробелами знак «равно», когда он употребляется для обозначения значения параметра по умолчанию. **print('My name', 'is', 'Python', sep='**', end='+')**
    5. Любую строку можно превратить в комментарий, поместив перед ней символ #.
    6. Согласно стандарту PEP 8, комментарии должны отделяться хотя бы двумя пробелами от кода. Они должны начинаться с символа # и одного пробела. **# Далее будет напечатан текст. print('Comments in Python') # Печать текста с помощью команды print.**
    7. Порядок выполнения операций в Python аналогичен порядку выполнения операций, которые вы изучали на уроках математики.
    8. Возведение в степень: ставим ** и нужную нам степень, например 3. Код будет такой: num = 2 ** 3; num = 8. **Обратите внимание:**
     оператор возведения в степень (`**`) является правоассоциативным (значение выражения вычисляется справа налево) в соответствии с правилами математики. Таким образом, выражение `x ** y ** z` вычисляется как `x ** (y ** z)`.
    9. Остаток от деления: ставим %
    10. // — целочисленное деление
    11. exit() — функция говорит программе, что код ниже запускать не надо.
    12. ‘\n’ — переход на новую строку.